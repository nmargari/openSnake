OpenSnake
----------------------------------------------------------------------------------------------------------------------------

Files: main.cpp, snake.cpp, sphere.cpp, handlers.cpp, defines.h, types.h

Compile: Ανοίγουμε ένα τερματικό και κάνουμε cd στο κατάλογο με τα αρχεία. Μετά
γράφουμε την εντολή: g++ main.cpp snake.cpp sphere.cpp handlers.cpp -lglut -o openSnake

Ερώτημα 1:

	Το πρόγραμμα μας παίρνει τα δεδομένα από το χρήστη χρησιμοποιώντας τις εντολές της C++.
	Ανοίγουμε ένα παράθυρο με την συνάρτηση glutCreateWindow() και τοποθετούμε τα φιδάκια στις
	αρχικές τους θέσεις καλώντας την συνάρτηση drawSnake(). Κάθε φίδι αποτελείται από κύβους και
	σφαίρες. Οι σφαίρες είναι οι αρθρώσεις που ενώνουν τους κύβους.
	Οι κύβοι ζωγραφίζονται με διαφορετικό χρώμα ο καθένας αντίθετα οι σφαίρες έχουν ένα σταθερό χρώμα
	διαφορετικό από τα χρώματα των κύβων. Για κάθε αντικείμενο που έχουμε υλοποιήσει έχουμε υπολογίσει
	και τα normal vectors.

Ερώτημα 2:

	Ο χρήστης έχει την δυνατότητα να αλλάζει την κάμερα. Μπορεί να περιστρέφεται γύρω από την σκηνή
	και να κάνει zoom in και zoom out. Επίσης υπάρχει η δυνατότητα να επιστρέψουμε στην αρχική θέση της
	κάμερας.

	Πλήκτρα:
	e: Επιστρέφει στην αρχική θέση
	z: Δεξιά περιστροφή ως προς τον z άξονα.
	Ζ: Αριστερή περιστροφή ως προς τον z άξονα.
	x: Προς τα πάνω περιστροφή ως προς τον x άξονα.
	X: Προς τα κάτω περιστροφή ως προς τον x άξονα.
	y: Αριστερή περιστροφή ως προς τον y άξονα.
	Y: Δεξιά περιστροφή ως προς τον y άξονα.
	j: Περιστροφή με δεξιά απομάκρυνση ως προς τον y άξονα.
	J: Περιστροφή με αριστερή απομάκρυνση ως προς τον y άξονα.
	k: Περιστροφή ως προς x με απομάκρυνση.
	K: Περιστροφή ως προς χ με απομάκυνση.
	l: zoom in.
	L: zoom out.
	Left arrow: Μετατόπιση ως προς το x άξονα.
	Right arrow: Μετατόπιση ως προς το x άξονα.
	Up arrow: Μετατόπιση ως προς το y άξονα.
	Down arrow: Μετατόπιση ως προς το y άξονα.
	Page Up: Μετατόπιση ως προς το z άξονα.
	Page Down: Μετατόπιση ως προς το z άξονα.

	Για να χειριστούμε τις ιδιότητες των πλήκτρων χρησιμοποιούμε δύο συναρτήσεις: keyboard() και specialKey().

Ερώτημα 3:

	Ο χρήστης θα μπορεί να τοποθετήσει μία ή περισσότερες σημειακές φωτεινές
	πηγές. Η πρώτη φωτεινή πηγή τοποθετείται στην θέση που έχει
	τοποθετηθεί η κάμερα και ακολουθεί τον μετασχηματισμό της και οι
	υπόλοιπες τοποθετούνται τυχαία στις γωνιακές κορυφές του πλέγματος. Όλες
	οι φωτεινές πηγές κοιτούν στο κέντρο του πλέγματος. Τα φώτα ανάβουν ένα ένα πατώντας το πλήκτρο q και σβήνουν όλα
	μαζί πατώντας το πλήκτρο Q. Η συνάρτηση που χειρίζεται τις φωτεινές πηγές είναι η createLight().

Ερώτημα 4:

	Όταν ο χρήστης πατάει το spacebar όλα τα φίδια θα αρχίζουν να κινούνται.
	Πατώντας «+» αυξάνεται η ταχύτητα κίνησης ενώ με το «-» μειώνεται.
	Όταν πατιέται το spacebar ξανά η κίνηση των φιδιών σταματά. Η κίνηση γίνεται τυχαία αρχίζοντας από το πρώτο κυβάκι 		και μετακινώντας το τυχαία σε μια από τις 6 κατευθύνσεις του ορίζοντα με
	απόσταση manhattan 1 από την προηγούμενη θέση του. Τα υπόλοιπα
	ακολουθούν έτσι ώστε να έχουν απόσταση manhattan 2 από αυτό που
	προηγήθηκε και τη μικρότερη δυνατή απόσταση manhattan από την
	προηγούμενη θέση τους. Σε περίπτωση που υπάρχουν περισσότερες από μία
	δυνατές θέσεις επιλέγεται μια από αυτές τυχαία. Η κίνηση περιορίζεται
	εντός του πλέγματος.

	Χρησιμοποιούμε την συνάρτηση random_move() της κλάσης snake για να μετακινήσουμε τυχαία το φίδι.
	Για την κίνηση του φιδιού γίνονται έλεγχοι για την σύγκρουσή του με άλλα αντικείμενα και για τη σωστή
	επιλογή θέσης ώστε να βρίσκεται μέσα στο χώρο που ορίζει ο χρήστης.

Ερώτημα 5:

	Όταν η χρήστης πατάει το «ο» εκτοξεύεται μια σφαίρα από μια τυχαία θέση
	του πλέγματος με κέντρο μια θέση του πλέγματος και ακτίνα ίση με την πλευρά
	ενός στοιχειώδους κύβου και σε τυχαία κατεύθυνση. Όταν η σφαίρα φτάνει στα όρια του πλέγματος
	εισέρχεται από την άλλη πλευρά. Η δημιουργία της σφαίρας πραγματοποιήται από την συνάρτηση
	createSphere() και η κίνηση της από τη συνάρτηση move() της κλάσης sphere.

Bonus:

	(a) Όταν ο χρήστης πατάει το «g» εμφανίζεται το πλέγμα και όταν το
            ξαναπατάει κρύβεται. Η συναρτησή που υλοποιεί το grid είναι η createGrid().
	(b) Εμφάνιση χαρακτηριστικoύ αριθμού στην κεφαλή κάθε φιδιού. Η εμφάνιση του αριθμού γίνεται με την βοήθεια
	    της συνάρτησης glutBitmapCharacter().
	(c) Εμφάνιση φωτεινών πηγών. Όταν μία φωτεινή πηγή γίνεται enable τότε με την βοήθεια της συνάρτησης
	    glutSolidSphere() εμφανίζουμε μία σφαίρα.

Extra:

	Άξονας: Το κέντρο του χώρου έχουν δημιουργηθεί οι άξονες x, y, z.

---------------------------------------------------------------------------------------------------------------------------

Κλάσεις και Τύποι δεδομένων

---------------------------------------------------------------------------------------------------------------------------

Έχουν δημιουργηθεί δύο κλάσεις η snake και η sphere.

class snake
{
public:
	int size;
	coord *coordinates;

	void set_coordinates(int x, int y, int z);
	void random_move();
};

class sphere
{
public:
	coord position;
	coord destination;

	void setRandomCoord();
	void move();
};

Επίσης έχει δημιουργηθεί και μία δομή δεδομένων coord.

typedef struct coord
{
	float x;
	float y;
	float z;
} coord;

13/04/2017 : Επιπρόσθετα, έχουν δημιουργηθεί τα κάτωθι:

(1, 2, 3, 4)

1) void handleArguments (struct XYZ &PointOnAxis, struct SizeOptions &NumericArgs)

Διαβάζει τα cmd line arguments και με βάση αυτά καθορίζει τις παραμέτρους δημιουργίας του φιδιού.
Ο λόγος που δημιούργησα structs, είναι για να ομαδοποιήσω τα arguments σε αυτά που πχ είναι

1.α) για συντεταγμένες (x,y,z)
1.β) τα args που είναι νουμερικές τιμές πχ πλήθος - μέγεθος φιδιών και grid_size.

Έτσι η handleArguments δεν παίρνει 7 (!) args να επεξεργαστεί αλλά μόλις 2 structs, με αναφορά.
Όταν επιστρέψει στην main() ξαναδίνει στις εκεί μεταβλητές (x,y,z) τις τιμές των μελών του εκάστοτε
struct και ΔΕΝ χρησιμοποιούνται τα structs (ΕΚΤΟΣ της XYZ::is_set). O μόνος λόγος ύπαρξης τους, είναι
το συμαζεμένο πέρασμα μεταβλητών από την handleArguments() πίσω στην main() για να σετάρει μεγέθη κτλ,
με βάση τα arguments του χρήστη.


1.α)
struct XYZ{
    int x = -1;
    int y = -1;
    int z = -1;
    bool is_set = false;
  };

Σε αυτό το struct κρατιούνται ομαδοποιημένες οι συντεταγμένες στις οποίες το φιδκάκι θα ξεκινήσει.
H is_set γίνεται true αν και μόνο το argument -c υπάρχει στη λίστα των ορισμάτων. Την χρησιμοποιούμε
αυτούσια στον έλεγχο της main() για να αποφασιστεί αν το πρόγραμμα θα ρωτήσει τον χρήστη για συντεταγμένες
ή αν έχει ήδη επιλέξει defaults με την -c (0, 0, 0) οπότε και εκκινεί σε αυτά τα σημεία το φιδάκι.

Το argument -c (ή --coordinates) στην κονσόλα, ΔΕΝ δίνει τιμές στα x,y,z απλώς τα *μηδενίζει*. Αν
ο χρήστης θέλει να δώσει συντεταγμένες, δεν δίνει argument και ερωτάται μέσα από το πρόγραμμα.


1.β)
struct SizeOptions{
    int grid_size = 0;
    int snake_num = 0;
    int snakeSize = 0;
  };

Σε αυτό το struct κρατιούνται ομαδοποιημένες οι νουμερικές μεταβλητές μεγεθών, πλήθους φιδιών...
Οι συναρτήσεις υπάρχουν στο helper_functions.cpp



2) Μια κλάση με το όνομα Program (ίσως το ProgrInfo να ήταν περιγραφικότερο)

class Program{

private:
    std::string m_name;
    std::string m_version;
    std::string m_author;
    int m_argc;
    char** m_argv;
    //Θα ήθελα οι 2 αυτές να είναι const.

public:
    Program(int argc, char** argv);
    std::string getName();
    std::string getVersionStr();
    std::string authorInfo();
    std::string getVersionMsg();
    void handleArguments (struct XYZ &PointOnAxis, struct SizeOptions &NumericArgs);
};

O σκοπός δημιουργίας της είναι να υπάρχουν κάποιες βασικές μεταβλητές, συναρτήσεις και πληριοφορίες για
το πρότζεκτ - πρόγραμμα (Program) και να είναι προσβάσιμες με κάποιες συναρτήσεις-μέλη κτλ. Χρησιμη είναι
για να παρέχει μέσω του constructor τα ορίσματα argc, **argv στην handleArguments και να χειρίζεται
εσωτερικά πληριοφορίες όπως versionMsg (= αλφαριθμητικό που μαζί με την έκδοση συνθέτει ένα μήνυμα),
versionStr (= αλφαριθμητικό της έκδοσης *μόνο* πχ 0.1.0), authorInfo κ.α.



3) Γράφτηκε μια createMenu() (openGL) στο helper_functions.cpp, όπου δεν κάνει τίποτα άλλο από το
εμφανίζει ένα "Quit openSnake" στο δεξί κλικ - και φυσικά να πράττει επιτυχώς ανάλογα. Την έγραψα
καθαρά για σκοπούς εκμάθησης, δεν φέρει βελτίωση ουτε λειτουργικότητα στο game.




4) Τέλος, ο χειρισμός των arguments, γίνεται με την 3rd party βιβλιοθήκη tclap, καθιστώντας την *υποχρεω-
τική* εξάρτηση μεν, κάνοντας cross-platform τον χειρισμό των argc, argv δε. Δεν έχω βρει τρόπο το cmake
να ελέγχει για την βιβλιοθήκη και να τυπώσει σφάλμα, που σημαίνει ότι θα τρομάξει τον ανυποψίαστο χρήστη
ο compiler με τα εκατομμύρια error.

http://tclap.sourceforge.net